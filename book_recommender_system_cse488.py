# -*- coding: utf-8 -*-
"""Book Recommender System - CSE488.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xI2K-OMlDCiQuJYU4j_QTQLImHdJoB5L

# **Data Pre-Processing**
"""

# Importing Important Libraries

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# Reading the Datasets (Books, Users, Ratings)

books = pd.read_csv('BX_Books.csv', sep = ";", error_bad_lines=False, encoding='latin-1')
users = pd.read_csv('BX-Users.csv', sep = ";", error_bad_lines=False, encoding='latin-1')
ratings = pd.read_csv('BX-Book-Ratings.csv', sep = ";", error_bad_lines=False, encoding='latin-1')

# Printing the Keys for all the Dataframes

b = books.keys()
u = users.keys()
r = ratings.keys()

print("Keys of Books:", b, "\n\nKeys of Users:", u, "\n\nKeys of Ratings:", r)

# Dropping the Image-URL-S, Image-URL-M, Image-URL-L from the books dataframe

books = books[['ISBN', 'Book-Title', 'Book-Author', 'Year-Of-Publication', 'Publisher']]

# Taking users who have been rated more than 200 books and merging it with the books dataframe

x = ratings['User-ID'].value_counts() > 200

y = x[x].index
y

ratings = ratings[ratings['User-ID'].isin(y)]

ratings_with_books = ratings.merge(books, on = "ISBN")

# Finding the number of rating counts from the ratings_with_books dataframe by using the groupby method

num_rating = ratings_with_books.groupby('Book-Title')['Book-Rating'].count().reset_index()

# Renaming the new column
num_rating.rename(columns={'Book-Rating':'Number-of-Rating'}, inplace = True)

# Merging the new column to the ratings_with_books dataframe
final_rating = ratings_with_books.merge(num_rating, on= 'Book-Title')

# Dropping duplicates from the final_rating
final_rating.drop_duplicates(['User-ID', 'Book-Title'], inplace=True)

final_rating.sample(5)

"""# **Generating Pivot Table**"""

# User-Item Matrix
book_pivot = final_rating.pivot_table(columns='Book-Title', index = 'User-ID', values='Book-Rating')

# Fill the NULL values with zeroes
book_pivot.fillna(0, inplace=True)

book_pivot

# Importing the compressed sparse row library
from scipy.sparse import csr_matrix

# Reducing the memory requirement for the above sparse matrix
book_sparse = csr_matrix(book_pivot)

"""# **KNN Model**"""

# Importing the NearestNeighbors Library
from sklearn.neighbors import NearestNeighbors

# KNN with ten neighbors
model = NearestNeighbors(n_neighbors=10, metric='cosine')
model.fit(book_pivot.values)

"""# **Function 1**"""

# Function that takes the user_id as input

def recommend_books_for_user(user_id):
    # Index to the user_id
    user_index = book_pivot.index.get_loc(user_id)

    # Nearest neighbors
    distances, suggestions = model.kneighbors(book_pivot.iloc[user_index].values.reshape(1, -1))

    # High rated books for simmilar users
    recommended_books = set()

    for sim_user_index in suggestions.flatten():

        # Index
        high_rated_books_indices = book_pivot.iloc[sim_user_index].index[book_pivot.iloc[sim_user_index] > 0]
        recommended_books.update(high_rated_books_indices)

    # Removing the already rated books
    target_user_rated_books_indices = book_pivot.columns[book_pivot.iloc[user_index] > 0]
    recommended_books -= set(target_user_rated_books_indices)

    # Top 10 recommended books
    top_ten_books = sorted(recommended_books, key=lambda book_index: book_pivot.iloc[suggestions.flatten()][book_index].mean(), reverse=True)[:10]

    return top_ten_books

# User ID
user_id = 254

# Calling the function with the user id
recommended_books = recommend_books_for_user(user_id)

print("Recommended Books:")
recommended_books

"""# **Generating a new Pivot Table for Function 2**"""

# Generating a new pivot table for the second function
book_pivot_new = final_rating.pivot_table(columns='User-ID', index='ISBN', values='Book-Rating')

# Replacing the null values with 0
book_pivot_new.fillna(0, inplace=True)

book_pivot_new

# Reducing the memory requirement for the above sparse matrix
book_sparse_new = csr_matrix(book_pivot_new)

"""# **Function 2**"""

# Function that will take user_id, isbn as input

def predict_book_rating(user_id, isbn):
    # Index to the user_id
    user_index = book_pivot_new.columns.get_loc(user_id)

    # Index of the ISBN
    isbn_index = book_pivot_new.index.get_loc(isbn)

    # Already Check User
    if book_pivot_new.iloc[isbn_index, user_index] > 0:
        return f"Already Rated. Rating: {book_pivot_new.iloc[isbn_index, user_index]}"

    # Nearest neighbors
    distances, suggestions = model.kneighbors(book_pivot_new.iloc[isbn_index].values.reshape(1, -1))

    # Prediction
    predicted_ratings = []
    for similar_user_index in suggestions.flatten():
        # Rating of similar user
        rating = book_pivot_new.iloc[isbn_index, similar_user_index]
        # Rating of similar user for prediction
        if rating > 0:
            predicted_ratings.append(rating)

    if predicted_ratings:
        predicted_rating = np.mean(predicted_ratings)
        return f"Rating: {predicted_rating}"

    # No Prediction
    return f"No Predictions"

user_id = 277427
isbn = '002542730X'

predicted_rating = predict_book_rating(user_id, isbn)
print("Prediction:")
predicted_rating